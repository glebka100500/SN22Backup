<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>80d915b2ef723100438236caa5c0fb37</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;package_private&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;global.SLARepairLog&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description&gt;Provides methods to log information about the Task SLAs that are repaired by calls to SLARepair&lt;/description&gt;
        &lt;name&gt;SLARepairLog&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var SLARepairLog = Class.create();

SLARepairLog.LOG_TABLE = "sla_repair_log";
SLARepairLog.LOG_ENTRY_TABLE = "sla_repair_log_entry";
SLARepairLog.LOG_MESSAGE_TABLE = "sla_repair_log_message";
SLARepairLog.LOG_PROPERTY = "com.snc.sla.repair.log";
SLARepairLog.FIELD_PREFIX = "tsla_";

SLARepairLog.prototype = {
    /**
     * @param type - String type of repair being logged
     * @param user - String user sys id startDate - GlideDateTime
     */
    initialize: function(type, user, startDate) {
        // Create a logger to log debug/error messages
        this.lu = new GSLog(SLARepairLog.LOG_PROPERTY, this.type);

        if (JSUtil.nil(type))
            return this.lu.logError("Error - type is mandatory");

        if (JSUtil.nil(user))
            return this.lu.logError("Error - user is mandatory");

        if (JSUtil.nil(startDate))
            return this.lu.logError("Error - startDate is mandatory");

        this.type = type;
        this.user = user;
        this.startDate = startDate;

		this._offlineUpdates = false;

		this._resetCounts();
    },

    /**
     * Creates a logging header record. The header record groups all the log entries created during a repair process.
     */
    startLog: function() {
        this._resetCounts();

        this.logGr = new GlideRecord(SLARepairLog.LOG_TABLE);
        this.logGr.setValue("active", true);
        this.logGr.setValue("type", this.type);
        this.logGr.setValue("sys_user", this.user);
        this.logGr.setValue("start_date", this.startDate);

        if (this.trackerId)
            this.logGr.sys_execution_tracker = this.trackerId;

        this.logGr.insert();
    },

    /**
     * Finishes the logging process. The end date and the number of records created/updated/deleted are set.
     */
    finishLog: function() {
        if (!this.logGr) {
            this.lu.logError("Error - Logging was never started, run startLog to create a sla_repair_log record");
            return;
        }

        this.logGr.setValue("active", false);
        this.logGr.setValue("end_date", gs.nowNoTZ());
        this.logGr.setValue("num_created", this.numCreated);
        this.logGr.setValue("num_updated", this.numUpdated);
        this.logGr.setValue("num_deleted", this.numDeleted);

        this.logGr.update();
    },
	
	logDebugMessage: function(message) {
		this._createMessage(message, "Debug");
	},

	logInfoMessage: function(message) {
		this._createMessage(message, "Information");
	},

	logWarningMessage: function(message) {
		this._createMessage(message, "Warning");
	},

	logErrorMessage: function(message) {
		this._createMessage(message, "Error");
	},

	/**
     * Increments the number created
     * 
     * @param value - Number to increment by. Defaults to 1
     */
    incrementCreated: function(value) {
        if (isNaN(value))
            value = 1;

        value = value - 0;

        this.numCreated += value;
    },

    /**
     * Increments the number updated
     * 
     * @param value - Number to increment by. Defaults to 1
     */
    incrementUpdated: function(value) {
        if (isNaN(value))
            value = 1;

        value = value - 0;

        this.numUpdated += value;
    },

    /**
     * Increments the number deleted
     * 
     * @param value - Number to increment by. Defaults to 1
     */
    incrementDeleted: function(value) {
        if (isNaN(value))
            value = 1;

        value = value - 0;

        this.numDeleted += value;
    },

    /**
     * Get the sys_id of the current log header record.
     * 
     * @return sys_id or null
     */
    getLogSysId: function() {
        if (!this.logGr)
            return null;

        return this.logGr.getValue("sys_id");
    },

    setTrackerId: function(trackerId) {
        this.trackerId = trackerId;
    },

    /**
     * Inserts a new 'before' log entry record.
     * 
     * Before entries represent the state of the Task SLA record before being repaired.
     * 
     * @param taskSlaGr - GlideRecord (task_sla)
     * 
     * @return - sys_id of created audit record
     */
    createBeforeEntry: function(taskSlaGr) {
        var auditGr = this._createAuditEntry(taskSlaGr, "before");
        if (auditGr)
            return auditGr.sys_id + '';

        return null;
    },

    /**
     * Inserts a new 'after' log entry record.
     * 
     * After entries represent the state of the Task SLA record after being repaired.
     * 
     * @param taskSlaGr - GlideRecord (task_sla)
     * 
     * @return - sys_id of created audit record
     */
    createAfterEntry: function(taskSlaGr) {
        var auditGr = this._createAuditEntry(taskSlaGr, "after");
        if (auditGr)
            return auditGr.sys_id + '';

        return null;
    },

	/**
     * Sets the value that will be used to populate the tsla_task_offline_updates flag in the
	 * sla_repair_log_entry record.
     *
     * @param hasOfflineUpdates - Boolean
     */
	setOfflineUpdate: function(hasOfflineUpdates) {
		this._offlineUpdates = "" + hasOfflineUpdates === "true";
	},

	_createAuditEntry: function(taskSlaGr, beforeOrAfter) {
        // Ensure expected arguments are provided
        if (JSUtil.nil(this.logGr))
            return this.lu.logError("Error - Audit record does not exist");

        if (JSUtil.nil(taskSlaGr))
            return this.lu.logError("Error - Task SLA is missing");

        if (JSUtil.typeOf(taskSlaGr.getRecordClassName) != "function" || taskSlaGr.getRecordClassName() != SLARepair.SLA)
            return this.lu.logError("Error - Task SLA is invalid");

        // Create a new Audit Entry
        var logEntryGr = new GlideRecord(SLARepairLog.LOG_ENTRY_TABLE);
        logEntryGr.initialize();

        // Copy values from the Task SLA into the Audit Entry 
        var elements = taskSlaGr.getElements();
        for (var i = 0; i &lt; elements.size(); i++) {
            var elementName = elements.get(i).getName();
            var targetField = SLARepairLog.FIELD_PREFIX + elementName;
            if (!taskSlaGr[elementName].nil() &amp;&amp; logEntryGr.isValidField(targetField))
                logEntryGr.setValue(targetField, taskSlaGr.getValue(elementName));
        }

        // Add some more values to the Audit Entry and then insert it
        logEntryGr.setValue(SLARepairLog.FIELD_PREFIX + "payload", "" + new GlideRecordSimpleSerializer().serialize(taskSlaGr));
        logEntryGr.setValue("type", beforeOrAfter);
        logEntryGr.setValue("tsla_task_offline_updates", this._offlineUpdates);
        logEntryGr.setValue(SLARepairLog.LOG_TABLE, this.logGr.getUniqueValue());
        logEntryGr.insert();

        // Return a reference to the Audit Entry record back to the caller
        return logEntryGr;
    },

	_resetCounts: function() {
        this.numUpdated = 0;
        this.numCreated = 0;
        this.numDeleted = 0;
    },
	
	_createMessage: function(message, level) {
        if (JSUtil.nil(this.logGr))
            return this.lu.logError("_createMessage: Audit record does not exist");

		if (!message)
			return;
		
		var levelValue = this._logLevel[level];

		var logMessageGr = new GlideRecord(SLARepairLog.LOG_MESSAGE_TABLE);
        logMessageGr.setValue(SLARepairLog.LOG_TABLE, this.logGr.getUniqueValue());
		logMessageGr.setValue("source", "SLARepair");
		logMessageGr.setValue("message", message);
		if (levelValue)
			logMessageGr.setValue("level", levelValue);
		logMessageGr.insert();
	},
		
	_logLevel: {
		Debug: -1,
		Information: 0,
		Warning: 1,
		Error: 2
	},

    type: "SLARepairLog"
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2015-03-18 09:50:16&lt;/sys_created_on&gt;
        &lt;sys_id&gt;80d915b2ef723100438236caa5c0fb37&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;105&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;SLARepairLog&lt;/sys_name&gt;
        &lt;sys_package display_value="Service level management" source="com.snc.sla"&gt;367209c76d6620100acb70b35343304f&lt;/sys_package&gt;
        &lt;sys_policy/&gt;
        &lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_80d915b2ef723100438236caa5c0fb37&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2018-11-07 14:31:55&lt;/sys_updated_on&gt;
        &lt;u_script_length&gt;7567&lt;/u_script_length&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2022-12-19 20:28:56</sys_created_on>
        <sys_id>edec8d3e2f331110d8a4d5f62799b6d3</sys_id>
        <sys_name>SLARepairLog</sys_name>
        <sys_package display_value="Integrations 2022" source="x_644088_integrati">4c7ca0582f0c9110d8a4d5f62799b66d</sys_package>
        <sys_policy/>
        <sys_scope display_value="Integrations 2022">4c7ca0582f0c9110d8a4d5f62799b66d</sys_scope>
        <sys_update_name>sys_metadata_link_edec8d3e2f331110d8a4d5f62799b6d3</sys_update_name>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
