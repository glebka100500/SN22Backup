<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>782a4ce9c370200014cc60eb5bba8f6d</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;package_private&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;global.AutomationEccSensorConditions&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description&gt;This collection of static functions is used by Discovery, Runbook, and core automation to decide if&amp;#13;
			an ecc_queue business rule should be run (the functions are intended to be called from the 'condition' field&amp;#13;
			of the business rule in question). In particular, see usage in the "Discover - Sensors" , "Automation -&amp;#13;
			Sensors" and "IntegrationHub - Sensors" business rules on the ecc_queue.&amp;#13;
 &amp;#13;
 This provides a mechanism to ensure that only one&amp;#13;
			sensor processor is called by flagging the ecc_queue record in-memory with the 'isProcessing' boolean flag.&amp;#13;
			If you want to extend this framework for a new sensor processor, please set the isProcessed flag and be&amp;#13;
			aware that whatever sensor processor picks up a job first will be the *only* one to process it.&amp;#13;
		&lt;/description&gt;
        &lt;name&gt;AutomationEccSensorConditions&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[AutomationEccSensorConditions = {
    /*
     * Determine if the given ecc_queue record should be processed by the RBA sensor processor (note that this same
     * processor is also used by core automation for SOAP and REST)
     * @param eccGr: the GlideRecord ecc_queue record to inspect ('current' when run from a BR condition)
     * returns: true if sensor script should be run, otherwise false
     */
    automation: function(eccGr) {
		if(!eccGr)
			return false;

        if (this._commonSkipConditions(eccGr)){
			return false;
		} else {
			//_commonSkipConditions() is used in Discovery as well. Don't move this condition inside _commonSkipConditions()
			//If no skip condition is matached, then check for agent correlator. Currently only Orchestraction, IntegrationHub, REST, SOAP update this field. This is ensure we execute the BR for Orchestraction, REST, SOAP
			if(gs.getProperty("glide.orchestration.enable_agent_correlator_check") === "true"){
				var agentCorrelator = eccGr.agent_correlator;
				if(agentCorrelator === null || agentCorrelator === undefined || String(agentCorrelator).length === 0)
					return false;
			}
		}

        // This field exists in javascript *only*, it is not a member of the GlideRecord, and will not persist across
        // execution contexts. This is used to ensure that only *one* sensor will process any given ecc_queue GR
        eccGr.isProcessed = true;
        return true;
    },
	
	/*
     * Determine if the given ecc_queue record should be processed by the IntegrationHub sensor processor
     * @param eccGr: the GlideRecord ecc_queue record to inspect ('current' when run from a BR condition)
     * returns: true if sensor script should be run, otherwise false
     */
    integrationHub: function(eccGr) {
		if(!eccGr)
			return false;

        if (this._commonSkipConditions(eccGr)){
			return false;
		} else {
			//_commonSkipConditions() is used in Discovery as well. Don't move this condition inside _commonSkipConditions()
			//we don't want ihub to process a record that's intended for runbook automation or discovery
			var agentCorrelator = eccGr.agent_correlator + '';
			if(agentCorrelator.indexOf('ihub.') != 0)
				return false;
		}

        // This field exists in javascript *only*, it is not a member of the GlideRecord, and will not persist across
        // execution contexts. This is used to ensure that only *one* sensor will process any given ecc_queue GR
        eccGr.isProcessed = true;
        return true;
    },

    /*
     * Determine if the given ecc_queue record should be processed by the Discovery sensor processor
     * @param eccGr: the GlideRecord ecc_queue record to inspect ('current' when run from a BR condition)
     * returns: true if sensor script should be run, otherwise false
     */
    discovery: function(eccGr) {
        // In addition to our common skip conditions, we don't want discovery to process a record that's intended for
        // runbook automation and Integration Hub
        var agent_correlator = eccGr.agent_correlator + '';
		if (this._commonSkipConditions(eccGr) ||
                agent_correlator.indexOf('rba.') === 0 || agent_correlator.indexOf('ihub.') === 0)
            return false;

		// If the probe results are the same as the last time we ran discover, then we will not need to process this sensor
		// The ecc_queue will be marked processed if this is the case.
		var payload = SNC.ParameterEncrypter.decryptIfFullyEncrypted(eccGr.payload) + '';
		if (payload == 'processed' || new GlideXMLParameters(payload).get('snc_payload_processed')) {
			eccGr.state = 'processed';
			eccGr.processed = (new GlideDateTime()).getDisplayValue();
			eccGr.update();

			// Update discovery status completed count
			DiscoveryStatus.updateStatusCompletedCount(agent_correlator);

			// Since classification_probe is part of ecc_queue.payload, it will not be available from the input record when
			// caching is enabled. Hence getting classification_probe from the output ecc queue to find the correct DH.
			var responseToGr = new GlideRecord('ecc_queue');
			responseToGr.get(eccGr.response_to);

			var probeResponse = SncProbe.createProbeResponse(responseToGr);
			// Update the device history completed count
			var dh = new DeviceHistoryJS();
			dh.reinitialize(eccGr.source + '', agent_correlator, probeResponse.getParameter('classification_probe'));
			dh.completed();

			return false;
		}

		// If the record is a PatternDebuggerProbe it should be processed synchronously
		// rather than put into the sys_trigger table for later processing
		// this is safe to do since the Pattern Debugger Sensor processes in less than 1 second
		if ((eccGr.topic + '') == 'PatternDebuggerProbe'){
			var job = new DiscoverySensorJob();
			job.process();

			return false;
		}

        // This field exists in javascript *only*, it is not a member of the GlideRecord, and will not persist across
        // execution contexts. This is used to ensure that only *one* sensor will process any given ecc_queue GR.
        eccGr.isProcessed = true;
        return true;
    },

	discoveryAccelerator: function(eccGr) {
		return (this.subnetDiscovery(eccGr) || this.midAutoConfig(eccGr));
	},

	/*
     * Determine if the given ecc_queue record should be processed by the midServer auto config processor
     * @param eccGr: the GlideRecord ecc_queue record to inspect ('current' when run from a BR condition)
     * returns: true if MidServerAutoConfig processor script should be run, otherwise false
     */
	midAutoConfig: function(eccGr) {
		if (this._commonSkipConditions(eccGr))
            return false;
		if (eccGr.topic != 'LightShazzam')
			return false;
		// This field exists in javascript *only*, it is not a member of the GlideRecord, and will not persist across
        // execution contexts. This is used to ensure that only *one* sensor will process any given ecc_queue GR
        eccGr.isProcessed = true;
        return true;
	},

    /*
     * Determine if the given ecc_queue record should be processed by the subnet discovery sensor processor
     * @param eccGr: the GlideRecord ecc_queue record to inspect ('current' when run from a BR condition)
     * returns: true if sensor script should be run, otherwise false
     */
    subnetDiscovery: function(eccGr) {
        if (this._commonSkipConditions(eccGr))
            return false;

		if (eccGr.name != 'Subnet Probe' || eccGr.topic != 'CommandPipeline')
			return false;

        // This field exists in javascript *only*, it is not a member of the GlideRecord, and will not persist across
        // execution contexts. This is used to ensure that only *one* sensor will process any given ecc_queue GR
        eccGr.isProcessed = true;
        return true;
    },

    /*
     * For local use, the set of common validations shared by all condition checks
     * @param eccGr: the GlideRecord ecc_queue record to inspect
     * returns: true if we should skip this ecc_queue record, false otherwise
     */
    _commonSkipConditions: function(eccGr) {
        // A hash of topics that we want to skip
        var badTopics = {
                'HeartbeatProbe': '',
                'config.file': '',
                'SystemCommand': '',
                'ConnectorProbe': '',
                'IPaaSActionProbe': '',
                'MonitoringProbe': '',
                'Syslog': ''
        };

        // If any of the below conditions evaluate to true, we should skip this ecc_queue GlideRecord
        if (!eccGr ||
                eccGr.isProcessed ||
                !eccGr.agent.startsWith('mid.server.') ||
                eccGr.queue != 'input' ||
                eccGr.state != 'ready' ||
                eccGr.topic.startsWith('queue.') ||
                eccGr.topic.startsWith('MIDExtension') ||
                eccGr.topic in badTopics)
            return true;

        return false;
    },

	/*
     * The set of common validations for output ecc_queue updates during sensor processing
     * @param eccGr: the GlideRecord ecc_queue record to inspect
     * returns: true if we should skip this ecc_queue record, false otherwise
     */
	skipSensorConditions: function(eccGr) {
		// A hash of topics that we want to skip
        var skipTopics = {
            'HeartbeatProbe': '',
            'config.file': '',
            'SystemCommand': '',
			'ConnectorProbe': ''
        };

		if (!eccGr ||
            eccGr.topic.startsWith('queue.') ||
            eccGr.topic.startsWith('MIDExtension') ||
            eccGr.topic in skipTopics)
            return true;

		if (eccGr.state.changesFrom('processing'))
			return true;

		if (eccGr.state.changesFrom('ready') &amp;&amp; eccGr.state.changesTo('processing'))
			return true;


        return false;
	}
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;ben.yukich&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2012-03-15 15:50:03&lt;/sys_created_on&gt;
        &lt;sys_id&gt;782a4ce9c370200014cc60eb5bba8f6d&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;58&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;AutomationEccSensorConditions&lt;/sys_name&gt;
        &lt;sys_package display_value="Core Automation" source="com.snc.core.automation"&gt;ee2289476d6620100acb70b3534330ff&lt;/sys_package&gt;
        &lt;sys_policy/&gt;
        &lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_782a4ce9c370200014cc60eb5bba8f6d&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;oron.subayi&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2021-10-01 23:33:17&lt;/sys_updated_on&gt;
        &lt;u_script_length&gt;8774&lt;/u_script_length&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2022-12-19 20:28:42</sys_created_on>
        <sys_id>4edc093e2f331110d8a4d5f62799b6af</sys_id>
        <sys_name>AutomationEccSensorConditions</sys_name>
        <sys_package display_value="Integrations 2022" source="x_644088_integrati">4c7ca0582f0c9110d8a4d5f62799b66d</sys_package>
        <sys_policy/>
        <sys_scope display_value="Integrations 2022">4c7ca0582f0c9110d8a4d5f62799b66d</sys_scope>
        <sys_update_name>sys_metadata_link_4edc093e2f331110d8a4d5f62799b6af</sys_update_name>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
