<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>49284de7c0a8018b3343c8783bcfc898</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;public&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;global.SkillManager&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description&gt;Manage operations related to users / groups / skills and inheritance&amp;#13;
- add inherited skills from a group to all users in the group&lt;/description&gt;
        &lt;name&gt;SkillManager&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[gs.include("PrototypeServer");

var SkillManager = Class.create();

SkillManager.prototype = {
	initialize: function() {
	},

	addInheritedSkills: function(/* GlideRecord */ groupSkill) {
		var members = GlideUserGroup.getMembers(groupSkill.group);
		while (members.next()) {
			var skill = new GlideRecord('sys_user_has_skill');
			skill.addQuery('user', members.user);
			skill.addQuery('skill', groupSkill.skill);
			skill.query();
			// if user already has the skill then skip the insert
			if(skill.next()){
				// check for the skill level coming from new group
				if(skill.skill_level_inherited &amp;&amp; skill.skill_level.value &lt; groupSkill.skill_level.value){
					skill.skill_level = groupSkill.skill_level;
					skill.setWorkflow(false);
					skill.update();
				}
			}else{
				skill.initialize();
				skill.user = members.user;
				skill.skill = groupSkill.skill;
				skill.skill_level = groupSkill.skill_level;
				skill.inherited = groupSkill.inherits;
				skill.inherited_from = groupSkill.group;
				skill.skill_level_inherited = true;
				skill.insert();
			}
		}
		this.addInheritedToGroups(groupSkill);
	},

	updateGroupUsersSkillLevel : function(groupSkill) {
		var members = GlideUserGroup.getMembers(groupSkill.group);
		while (members.next()) {
			var skill = new GlideRecord('sys_user_has_skill');
			skill.addQuery('user', members.user);
			skill.addQuery('skill', groupSkill.skill);
			// update the skill level for inherited levels only
			skill.addQuery('skill_level_inherited', true);
			skill.query();
			if(skill.next()){
				// check if the new level is higher than other parent group levels
				var groups = GlideUserGroup.getUsersGroups(skill.user);
				var skillLevel = groupSkill.skill_level;
				if(groups.size() &gt; 1){
					var groupLevel = new GlideRecord('sys_group_has_skill');
					groupLevel.addQuery('group' ,'IN', groups.toString());
					groupLevel.addQuery('skill', skill.skill);
					groupLevel.orderByDesc('skill_level.value');
					groupLevel.setLimit(1);
					groupLevel.query();
					if(groupLevel.next())
						skillLevel = groupLevel.getValue('skill_level');
				}
				skill.skill_level = skillLevel;
				skill.setWorkflow(false);
				skill.setForceUpdate(true);
				skill.update();
			}
		}
		this.updateSkillLevelInheritedToGroups(groupSkill);
	},

	updateSkillLevelInheritedToGroups: function(/* GlideRecord */ groupSkill) {
		var children = new GlideRecord('sys_user_group');
		children.addQuery('parent', groupSkill.group);
		children.query();
		while (children.next()) {
			var c = new GlideRecord('sys_group_has_skill');
			c.addQuery('group', children.sys_id);
			c.addQuery('skill', groupSkill.skill);
			// update the skill level for inherited levels only
			c.addQuery('skill_level_inherited', true);
			c.query();
			if(c.next()){
				c.skill_level = groupSkill.skill_level;
				c.update();
			}
		}
	},

	addInheritedToGroups: function(/* GlideRecord */ groupSkill) {
		var children = new GlideRecord('sys_user_group');
		children.addQuery('parent', groupSkill.group);
		children.query();
		while (children.next()) {
			var c = new GlideRecord('sys_group_has_skill');
			c.addQuery('group', children.sys_id);
			c.addQuery('skill', groupSkill.skill);
			c.query();
			if(c.next()){
				if(!c.skill_level_inherited &amp;&amp; c.skill_level.value &lt; groupSkill.skill_level.value){
					c.skill_level = groupSkill.skill_level;
					c.update();
				}
			}else {
				c.initialize();
				c.group = children.sys_id;
				c.inherited_from = groupSkill.group;
				c.inherits = groupSkill.inherits;
				c.skill = groupSkill.skill;
				c.skill_level = groupSkill.skill_level;
				c.skill_level_inherited = true;
				c.insert();
			}

		}
	},

	deleteInheritedSkills: function(/* GlideRecord */ groupSkill) {
		var gr = new GlideRecord('sys_user_has_skill');
		gr.initialize();
		gr.addQuery('inherited_from', groupSkill.group);
		gr.addQuery('skill', groupSkill.skill);
		gr.addQuery('inherited', true);
		gr.deleteMultiple();
		this.deleteInheritedFromGroups(groupSkill);
	},

	deleteInheritedFromGroups: function(/* GlideRecord */ groupSkill) {
		var gr = new GlideRecord('sys_group_has_skill');
		gr.initialize();
		gr.addQuery('inherited_from', groupSkill.group);
		gr.addQuery('skill', groupSkill.skill);
		gr.addQuery('inherited', true);
		gr.deleteMultiple();

	},

	deleteAllSkills: function(/* GlideRecord */ groupSkill) {
		var gr = new GlideRecord('sys_user_has_skill');
		gr.initialize();
		gr.addQuery('inherited_from', groupSkill.group);
		gr.addQuery('skill', groupSkill.skill);
		gr.deleteMultiple();
	},

	// when sys_user_group.parent changes
	removeGroupSkillsFromChild: function(/* String */ parent, /* String */ child) {
		var gr = new GlideRecord('sys_group_has_skill');
		gr.addQuery('group', child);
		gr.addQuery('inherited_from', parent);
		gr.deleteMultiple();
	},

	// adds all inherited group skills to a child group
	// when sys_user_group.parent changes
	addGroupSkillsToChild: function(/* String */ parent, /* String */ child) {
		var parentSkills = new GlideRecord('sys_group_has_skill');
		parentSkills.addQuery('group', parent);
		parentSkills.addQuery('inherits', true);
		parentSkills.query();
		while (parentSkills.next()) {
			var c = new GlideRecord('sys_group_has_skill');
			c.initialize();
			c.group = child;
			c.inherited_from = parent;
			c.inherits = parentSkills.inherits;
			c.skill = parentSkills.skill;
			c.insert();
		}
	},

	// Support for included skills from here down

	/* Called when a skill is added to another skill e.g. we say "DBA now includes MySQL DBA"
 	*/
	addIncludedSkill: function(/* GlideRecord */ inclusion) {
		var master = inclusion.skill;
		var contains = inclusion.contains;
		var expand = new GlideRecord('sys_user_has_skill');
		expand.addQuery('skill', master);
		expand.query();
		while (expand.next()) {
			var newSkill = new GlideRecord('sys_user_has_skill');
			newSkill.initialize();
			newSkill.user = expand.user;
			newSkill.skill = contains;
			newSkill.inherited_from = expand.inherited_from;
			newSkill.inherited = true;
			newSkill.included_in_skill = expand.sys_id;
			newSkill.included_in_skill_instance = inclusion.sys_id;
			newSkill.insert();
		}
	},

	/* Called when a skill is removed from another skill e.g. we say "Network now no longer includes Network wiring"
 	*/
	removeIncludedSkill: function(/* GlideRecord */ inclusion) {
		var expand = new GlideRecord('sys_user_has_skill');
		expand.addQuery('included_in_skill_instance', inclusion.sys_id);
		expand.query();
		while (expand.next()) {
			expand.deleteRecord();
		}
	},

	/* Called when a skill is added to the sys_user_has_skill table.
	Responsible for expanding (adding) any skills contained within the skill in question
	Exception: skills that the user already had and were not inherited from another skill are not added
 	*/
	expandSkill: function(/* GlideRecord */ sys_user_has_skill) {
		var topLevel = false;
		if (typeof SKILL_HASH == 'undefined' || SKILL_HASH == null) {
			topLevel = true;
			SKILL_HASH = new Object();
		}
		var key = sys_user_has_skill.skill + '';
		SKILL_HASH[key] = true;
		var expansion = new GlideRecord('cmn_skill_contains');
		expansion.addQuery('skill', sys_user_has_skill.skill);
		expansion.addQuery('contains.active', true);
		expansion.query();
		while (expansion.next()) {
			var childkey = expansion.contains + '';
			if (SKILL_HASH[childkey])
				continue;

			var genuineSkill = new GlideRecord('sys_user_has_skill');
			genuineSkill.addQuery('user', sys_user_has_skill.user);
			genuineSkill.addQuery('skill', childkey);
			genuineSkill.addQuery('included_in_skill', '');
			genuineSkill.query();
			if (genuineSkill.next())
				continue;

			var newSkill = new GlideRecord('sys_user_has_skill');
			newSkill.initialize();
			newSkill.user = sys_user_has_skill.user;
			newSkill.skill = expansion.contains;
			newSkill.inherited = true;
			newSkill.inherited_from = sys_user_has_skill.inherited_from;
			newSkill.included_in_skill = sys_user_has_skill.sys_id;
			newSkill.included_in_skill_instance = expansion.sys_id;
			newSkill.insert();
		}
		if (topLevel)
			SKILL_HASH = null;
	},

	/* Called when a skill is deleted from the sys_user_has_skill table.
	Responsible for removing any skills that were added on account of this skill.
	For example, if DBA contains MYSQL DBA and we grant DBA to Alex B
	Alex now has DBA and MYSQL DBA
	If we remove DBA from Alex, he has to lose MYSQL as well
 	*/
	deleteSkill: function(/* GlideRecord */ sys_user_has_skill) {
		var kids = new GlideRecord('sys_user_has_skill');
		kids.addQuery('included_in_skill', sys_user_has_skill.sys_id);
		kids.query();
		while (kids.next()) {
			kids.deleteRecord();
		}
	},

	z: function() {}
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;dariusz.maint&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2010-03-10 17:38:50&lt;/sys_created_on&gt;
        &lt;sys_id&gt;49284de7c0a8018b3343c8783bcfc898&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;94&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;SkillManager&lt;/sys_name&gt;
        &lt;sys_package display_value="Skills Management" source="com.snc.skills_management"&gt;6c463c602fa33010d8a4d5f62799b6ab&lt;/sys_package&gt;
        &lt;sys_policy/&gt;
        &lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_49284de7c0a8018b3343c8783bcfc898&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2019-06-12 19:24:49&lt;/sys_updated_on&gt;
        &lt;u_script_length&gt;8716&lt;/u_script_length&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2022-12-19 20:27:16</sys_created_on>
        <sys_id>748c0dba2f331110d8a4d5f62799b6fc</sys_id>
        <sys_name>SkillManager</sys_name>
        <sys_package display_value="Integrations 2022" source="x_644088_integrati">4c7ca0582f0c9110d8a4d5f62799b66d</sys_package>
        <sys_policy/>
        <sys_scope display_value="Integrations 2022">4c7ca0582f0c9110d8a4d5f62799b66d</sys_scope>
        <sys_update_name>sys_metadata_link_748c0dba2f331110d8a4d5f62799b6fc</sys_update_name>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
