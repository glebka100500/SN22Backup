<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>860655720a0a0b61002e116c36243127</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;package_private&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;global.SOAPRequest&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description&gt;Invoke a SOAP service using a SOAPEnvelope as input&lt;/description&gt;
        &lt;name&gt;SOAPRequest&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[gs.include("PrototypeServer");

var SOAPRequest = Class.create();

/**
 * SOAPRequest takes a SOAPEnvelope or string representation of a SOAP envelope
 * and posts it to the specified endpoint
 */
SOAPRequest.prototype = {
  initialize: function(endpoint, userName, password) {
    this.endpoint = endpoint;
    this.httpStatus = null;
    this.responseDoc; // a string of the response
    this.soapAction;
    this.userName = userName;
    this.password = password;
    this.proxyHost;
    this.proxyPort = 80;
    this.postMethod;
    this.errorMessage;
    this.midServer; // mid server name
    this.requestHeaders = new Object();
    this.httpHeaderMap = {};
  },

  /**
   * posting a SOAPEnvelope object, optionally specifying whether
   * to use the ECC table to send the request
   */
  post: function(soapEnvelope, use_ecc) {

    this.httpStatus = null
    this.errorMessage = null;
    this.responseDoc = null

    var action = soapEnvelope.functionName;
    if (this.soapAction)
      action = this.soapAction;

    if (use_ecc) {
      var cred = this.encodeCredentials();
      if (this.midServer) {
        soapEnvelope.setMIDServer(this.midServer);
      }

      soapEnvelope.invokeService(this.endpoint, action, cred);
      return;
    }

    var soapDoc = soapEnvelope.toString() + ''; // make sure that it is a javascript string
    return this.postString(soapDoc, action);
  },

  /**
   * encode basic auth credentials, to be used when invoking SOAP
   * through the ECC queue
   */
  encodeCredentials: function() {
    if (this.userName == null)
      return "";

    var str = this.userName + ":" + this.password;
    var e = new GlideEncrypter();
    return e.encrypt(str);
  },

  /**
   * posting a string representation of the SOAP envelope
   */
  postString: function(soapDoc, action) {

    this.httpStatus = null
    this.errorMessage = null;
    this.responseDoc = null

    // must initialize first, to get extended protocols and SSL context
    // before making a new PostMethod
    var httpClient = new GlideHTTPClient();

    try {
      this.postMethod = new Packages.org.apache.commons.httpclient.methods.PostMethod(this.endpoint);
      this.postMethod.setRequestHeader("Content-Type", "text/xml; charset=UTF-8");
      this.postMethod.setRequestHeader("SoapAction", this.wrapQuotes(action));

      for(key in this.requestHeaders) {
        this.postMethod.setRequestHeader(key, this.requestHeaders[key]);
      }

      this.postMethod.setRequestBody(soapDoc);

      if (this.userName) {
        httpClient.setBasicAuth(this.userName, this.password);
      }

      if (this.proxyHost) {
        if (this.proxyHost == "unset") {
          httpClient.setHostConfiguration(new Packages.org.apache.commons.httpclient.HostConfiguration());
        } else {
          httpClient.setupProxy(this.proxyHost, this.proxyPort);
        }
      }

      var result = httpClient.executeMethod(this.postMethod);
      this.httpStatus = result;

      this.errorMessage = httpClient.getErrorMessage();

	  var headers = this.postMethod.getResponseHeaders();
	  for (var i = 0; i &lt; headers.length; i++) {
		  this.httpHeaderMap[headers[i].getName()] = headers[i].getValue();
	  }
		
      this.responseDoc = this.postMethod.getResponseBodyAsString();
      this.postMethod.releaseConnection();
      return this.responseDoc;
    } catch (e) {
      this.errorMessage = e.toString();
      
      var sb = new Packages.java.lang.StringBuffer();   
      var st = e.getStackTrace();
      for (var i = 0; i &lt; st.length; i++) {
        sb.append(st[i].toString() + "\n");
      }        
    
      return this.errorMessage + "\n" + sb.toString();
    } finally {
      this.postMethod.releaseConnection();
    }
  },

  /**
   * Wrap specified string in double-quotes unless it is already wrapped
   */
  wrapQuotes : function (str) {
    if (str !== null)
      str = "\"" + str.trim().replace(/^"/, "").replace(/"$/, "") + "\"";

    return str;
  },

  /**
   * setup proxy servers for the HTTP post
   */
  setupProxy : function (host, port) {
    this.proxyHost = host;
    if (port) {
      this.proxyPort = port; // defaults to 80
    }
  },

  /**
   * set the SOAP action HTTP header
   */
  setSoapAction: function(action) {
    this.soapAction = action;
  },

  setMIDServer : function(name) {
    this.midServer = name;
  },

  /**
   * get the response string
   */
  getResponseDoc: function() {
    return this.responseDoc;
  },

  getResponseHeaderValue: function(headerName) {
    var header = this.postMethod.getResponseHeader(headerName);
    return header.getValue();
  },

  setRequestHeader: function(headerName, headerValue) {
    this.requestHeaders[headerName]=headerValue;
  },

  /**
   * get the HTTP status of the post
   */
  getHttpStatus: function() {
    return this.httpStatus;
  },
  /**
   * get the error message as a result of the post
   */
  getErrorMessage: function() {
    return this.errorMessage;
  },
	
	getHttpHeaders: function() {
		return this.httpHeaderMap;
	},
	
	getHttpHeader: function(name) {
		return this.httpHeaderMap[name];
	}
	
};
]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;glide.maint&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2008-06-14 07:42:19&lt;/sys_created_on&gt;
        &lt;sys_id&gt;860655720a0a0b61002e116c36243127&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;181&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;SOAPRequest&lt;/sys_name&gt;
        &lt;sys_package display_value="Web Service Consumer" source="com.glide.web_service_consumer"&gt;c8dcb8836d2220100acb70b35343301b&lt;/sys_package&gt;
        &lt;sys_policy/&gt;
        &lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_860655720a0a0b61002e116c36243127&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2013-07-24 17:18:53&lt;/sys_updated_on&gt;
        &lt;u_script_length&gt;5119&lt;/u_script_length&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2022-12-19 20:29:07</sys_created_on>
        <sys_id>04fc817e2f331110d8a4d5f62799b69f</sys_id>
        <sys_name>SOAPRequest</sys_name>
        <sys_package display_value="Integrations 2022" source="x_644088_integrati">4c7ca0582f0c9110d8a4d5f62799b66d</sys_package>
        <sys_policy/>
        <sys_scope display_value="Integrations 2022">4c7ca0582f0c9110d8a4d5f62799b66d</sys_scope>
        <sys_update_name>sys_metadata_link_04fc817e2f331110d8a4d5f62799b69f</sys_update_name>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
