<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>0c7c54b00b06030031a567bff6673ac0</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;package_private&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;global.pwdEnrollmentReminderHelper&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description/&gt;
        &lt;name&gt;pwdEnrollmentReminderHelper&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var pwdEnrollmentReminderHelper = Class.create();
pwdEnrollmentReminderHelper.prototype = {
	ENROLL_REMINDER_CHILD_SCHEDULED_JOB_PREFIX: "pwd_",
	EMAIL_BATCH_SIZE_PROPERTY: "password_reset.enrollment_reminder.email_batch_size",
	EMAIL_BATCH_EXECUTION_DELAY: 900, //child schedule jobs will be scheduled to run 15 mins after current time
	TO_EMAIL_ADDRESS: "do-not-reply@servicenow.com",
	SYS_TRIGGER_JOB_ID: "81c92ce9c0a8016400e5f0d2f784ea78",
	
	initialize: function() {
	},
	
	sendReminderToNotEnrolledUsersForProcess: function(processId) {
		var limit = GlidePropertiesDB.get(this.EMAIL_BATCH_SIZE_PROPERTY);
		var currentTime = new GlideDateTime();
		this._createRunOnceChildScheduledJob(0, limit, processId, currentTime);
	},
	
	sendReminderInBatch: function(start, limit, processId) {
		var process = this._getProcessGr(processId);
		if(gs.nil(process)) {
			gs.info("Process not found");
			return false;
		}
		if(process.apply_to_all_users) {
			this.processAllUsers(start, limit, process);
		} else {
			this.processUsersFromGroup(start, limit, process);
		}
	},
		
	processAllUsers: function(start, limit, process) {
		var userIds = [];
		var users = this.getUsersInBatch(start, limit);
		if(!gs.nil(users)) {
			do {
				var userId = users.getValue("sys_id");
				if(this.getEnrollmentStatusForProcess(userId, process))
					continue;
				userIds.push(userId);
			} while(users.next());

			var newStart = start+limit;
			this.sendNotificationAndSetUpNextBatch(userIds, newStart, start, limit, process.sys_id);
		}
	},
	
	processUsersFromGroup: function(start, limit, process) {
		var userIds = [];
		var users = this.getUserListFromGroupsInBatch(start, limit, process);
		if(!gs.nil(users)) {
			do {
				var userId = users.getValue("user") + '';
				if(this.getEnrollmentStatusForProcess(userId, process))
					continue;
				userIds.push(userId);
			} while(users.next());
			//start for new batch.. 
			// Last index is included in GlideAggregate query that's why new start is start + limit + 1 instead start + limit. 
			var newStart = start + limit + 1;
			this.sendNotificationAndSetUpNextBatch(userIds, newStart, start, limit, process.sys_id);
		}
	},
	
	sendNotificationAndSetUpNextBatch: function(userIds, newStart, start, limit, processId) {
		if(userIds.length) {
			var procGr = this._getProcessGr(processId);
			var toRecipients = procGr.getValue("sender_alias");
			if(gs.nil(toRecipients)) 
				toRecipients = this.TO_EMAIL_ADDRESS;
			gs.eventQueue("pwd.enrollment_reminder.trigger", null, toRecipients, userIds.join(","));
		}

		var currentTime = new GlideDateTime();
		currentTime.addSeconds(this.EMAIL_BATCH_EXECUTION_DELAY);
		//create new child job for next batch of users
		this._createRunOnceChildScheduledJob(newStart, limit, processId, currentTime);
	},
			
	getUserListFromGroupsInBatch: function(start, limit, process) {
		var userGroups = [];
		var end = start + limit;
		
		var gr = new GlideRecord("pwd_map_proc_to_group");
		gr.addQuery("process", process.getValue("sys_id"));
		gr.query();
		while(gr.next()) {
			userGroups.push(gr.getValue("user_group"));
		}
		var userGrpMemGr = new GlideAggregate("sys_user_grmember");
		userGrpMemGr.addQuery("group", "IN", userGroups.join());
		userGrpMemGr.addQuery("user.active", true);
		userGrpMemGr.addQuery("user.notification", 2);
		userGrpMemGr.addNotNullQuery("user.email");
		userGrpMemGr.addAggregate('COUNT(DISTINCT', 'user');
        userGrpMemGr.orderBy("user.sys_created_on");
		userGrpMemGr.groupBy('user');
		userGrpMemGr.chooseWindow(start, end, true);
		userGrpMemGr.query();
		if(userGrpMemGr.next())
			return userGrpMemGr;
		return null;
	},
	
	getUsersInBatch: function(start, limit) {
		var end = start + limit;
		var gr = new GlideRecord("sys_user");
		gr.addActiveQuery();
		gr.addQuery("notification", 2); //notification is enabled
		gr.addNotNullQuery("email");
		gr.chooseWindow(start, end, true);
		gr.orderBy("sys_created_on");
		gr.query();
		if(gr.next())
			return gr;
		return null;
	},
			
	getEnrollmentStatusForProcess: function(userId, process) {

		var verificationsEnrolled = 0;
		var minimumVers =  process.getValue("min_verifications");
		//Check if user is enrolled in all mandatory verifications
		var result = this.getUserEnrollmentstatusForMandatoryVerifications(userId, process);
		if(!result.enrolled){
			return false;
		}

		verificationsEnrolled = result.enrolledVerificationCount;
		if(verificationsEnrolled &gt;= minimumVers)
			return true;

		result = this.getUserEnrollmentstatusForNonMandatoryVerifications(userId, process, false);
		verificationsEnrolled = verificationsEnrolled + result.enrolledVerificationCount;
		if(verificationsEnrolled &gt;= minimumVers)
			return true;

		return false;
	},
			
	getUserEnrollmentstatusForMandatoryVerifications: function(userId, process) {
		return this.getUserEnrollmentStatusForVerifications(userId, process, true);
	},

	getUserEnrollmentstatusForNonMandatoryVerifications: function(userId, process) {
		return this.getUserEnrollmentStatusForVerifications(userId, process, false);
	},

	getUserEnrollmentStatusForVerifications: function(userId, process, mandatory) {
		var result = {enrolled: false, enrolledVerificationCount:0 };
		var verificationIds = new SNC.PwdProcessManager().getProcessVerificationIdsByMandatoryFlag(process.getValue("sys_id"), mandatory);
		var versArr = [];
		for (var i = 0; i != verificationIds.size(); ++i)
			versArr.push(verificationIds.get(i));
		
		var pwdEnrollmentMgr = new SNC.PwdEnrollmentManager();
		for (var j  = 0; j &lt; versArr.length; j++) {
			if(pwdEnrollmentMgr.isUserEnrolledByVerificationId(userId, versArr[j]))
				result.enrolledVerificationCount++;
		}
		result.enrolled =  result.enrolledVerificationCount == versArr.length;
		return result;
	},
	
	_getProcessGr : function(processId) {
		var gr = new GlideRecord("pwd_process");
		if(gr.get(processId))
			return gr;
		return null;
	},

	_createRunOnceChildScheduledJob: function(start, limit, processId, startTime) {
		var gr = new GlideRecord("sys_trigger");
		gr.setValue("name", this._getChildScheduleJobName(processId, start));
		gr.setValue("trigger_type", "0"); // run once
		gr.setValue("state", "0"); // ready
		gr.setValue("next_action", startTime);
		gr.setValue("script", this._getChildScheduleJobScript(start, limit, processId));
		gr.setValue("job_id", this.SYS_TRIGGER_JOB_ID);
		return gr.insert();
	},
	
	_getChildScheduleJobScript: function(start, limit, processId) {
		return "new pwdEnrollmentReminderHelper().sendReminderInBatch("+ start +", " + limit + ", \'" + processId + "\');";
	},
	
	_getChildScheduleJobName: function(processId, start) {
		return this.ENROLL_REMINDER_CHILD_SCHEDULED_JOB_PREFIX + processId + "_" + start;
	},
	
	deleteChildScheduleJob: function(processId){
		var gr = new GlideRecord("sys_trigger");
		gr.addQuery("name", "STARTSWITH" , this.ENROLL_REMINDER_CHILD_SCHEDULED_JOB_PREFIX + processId);
		gr.query();
		if(gr.next())
			gr.deleteRecord();
	},
	
	type: 'pwdEnrollmentReminderHelper'
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2017-10-23 22:20:30&lt;/sys_created_on&gt;
        &lt;sys_id&gt;0c7c54b00b06030031a567bff6673ac0&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;128&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;pwdEnrollmentReminderHelper&lt;/sys_name&gt;
        &lt;sys_package display_value="Password Reset" source="com.glideapp.password_reset"&gt;a54385836da620100acb70b3534330a5&lt;/sys_package&gt;
        &lt;sys_policy/&gt;
        &lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_0c7c54b00b06030031a567bff6673ac0&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2017-11-15 05:28:31&lt;/sys_updated_on&gt;
        &lt;u_script_length&gt;7023&lt;/u_script_length&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2022-12-19 20:25:57</sys_created_on>
        <sys_id>293c817a2f331110d8a4d5f62799b680</sys_id>
        <sys_name>pwdEnrollmentReminderHelper</sys_name>
        <sys_package display_value="Integrations 2022" source="x_644088_integrati">4c7ca0582f0c9110d8a4d5f62799b66d</sys_package>
        <sys_policy/>
        <sys_scope display_value="Integrations 2022">4c7ca0582f0c9110d8a4d5f62799b66d</sys_scope>
        <sys_update_name>sys_metadata_link_293c817a2f331110d8a4d5f62799b680</sys_update_name>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
