<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>979a5dde0ab3015252383b43d9a73436</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;package_private&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;global.MonitorMIDServer&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description&gt;Monitors MID servers, using the heartbeat probe.&lt;/description&gt;
        &lt;name&gt;MonitorMIDServer&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[/*
 * Monitors MID servers, using the heartbeat probe.
 */

var MonitorMIDServer = Class.create();

MonitorMIDServer.STATUS_RECORD = 'mid.monitor.heartbeat_sent';

MonitorMIDServer.prototype = {
    
    /*
     * Do everything required for a scheduled MID server monitor cycle.
     */
    monitor: function() {
        this.killOldRequests();
        this.markDowners();
        this.sendHeartbeatRequests();
    },
    
    /*
     * Mark any non-responding MID servers as being down.
     *
     * There are two timestamps that are updated separately:
     *   1. last_heartbeat_sent is the last time an output heartbeat message was sent by this monitor.
     *   2. last_refreshed is the last time the mid server status was updated.
     *
     * The monitor looks for any mid server activity (last_refreshed is updated or any ecc input message)
     * between now and last_heartbeat_sent, and if there is nothing, it will mark the mid server as Down.
     *
     * Because of the time drift issue when moving between nodes, last_refreshed and last_heartbeat_sent
     * can be few seconds before or after the actual time.  To solve the issue, we extends the query window
     * to the past by substracting some extra time from last_heartbeat_sent.
     */
    markDowners: function() {
        // find the last time we sent a heartbeat...
        var gr = new GlideRecord('sys_status');
        gr.addQuery('name', MonitorMIDServer.STATUS_RECORD);
        gr.query();
        if (!gr.next())
            return;
        var last_heartbeat_sent = new GlideDateTime(gr.value);
        // add some extra time to query condition to address the time drift issue when moving between instance nodes
        last_heartbeat_sent.addSeconds(-5);

        // find all the non-responding MID servers...
        gr = new GlideRecord('ecc_agent');
        gr.addQuery('last_refreshed', '&lt;', last_heartbeat_sent);
        gr.addQuery('status', '!=', 'Down');
        gr.query();
        while (gr.next()) {
            if (! this.hasRecentActivity('' + gr.name, last_heartbeat_sent)) {
                gr.status = 'Down';
                gr.update();
            }
        }
    },
    
    /*
     * Check if the given agent name has written to the ecc_queue more recently than the given time.
     * This protects against marking an overloaded (but functioning) mid server as 'down' inappropriately.
     */
    hasRecentActivity: function(agentName, time) {
        var gr = new GlideRecord('ecc_queue');
        gr.addQuery('sys_created_on', '&gt;=', time);
        // time bound is an optimization to tell GR to focus on one or two ecc_queue shards and not join all shards
        gr.addQuery('sys_created_on', '&lt;=', gs.minutesAgo(0));
        gr.addQuery('agent', 'mid.server.' + agentName);
        gr.addQuery('queue', 'input');
        gr.query();
        if (gr.hasNext())
            return true;
        
        return false;
    },

    /*
     * Send heartbeat requests to all MID servers, and note when we did it.
     */
    sendHeartbeatRequests: function() {
        // first send the requests...
        var now = gs.nowNoTZ();
        var gr = new GlideRecord('ecc_queue');
        gr.initialize();
        gr.agent = 'mid.server.*';  // a business rule turns this into individual requests...
        gr.queue = 'output';
		gr.priority = 0;
        gr.topic = 'HeartbeatProbe';
        gr.state = 'ready';
        gr.insert();
        
        // then update or insert our status record to show when we sent them...
        gr = new GlideRecord('sys_status');
        gr.addQuery('name', MonitorMIDServer.STATUS_RECORD);
        gr.query();
        if (gr.next()) {
            gr.value = now;
            gr.update();
        } else {
            gr.initialize();
            gr.value = now;
            gr.name = MonitorMIDServer.STATUS_RECORD;
            gr.description = 'Last time MID server heartbeat probes were launched';
            gr.insert();
        }
    },
    
    /*
     * If there are any heartbeat probe requests that haven't been processed, cancel them so that they don't accumulate when
     * a MID server is down for a while...
     */
    killOldRequests: function() {
        var gr = new GlideRecord('ecc_queue');
        gr.addQuery('agent', 'STARTSWITH', 'mid.server.');
        gr.addQuery('queue', 'output');
        gr.addQuery('state', '!=', 'processed');
        gr.addQuery('topic', 'HeartbeatProbe');
        gr.addQuery("sys_created_on", "&gt;", gs.minutesAgo(10));
        gr.addQuery("sys_created_on", "&lt;=", gs.minutesAgo(0)); // Bound the ecc_queue because of potential table rotation schedules in the future
        gr.query();
        while (gr.next()) {
            gr.state = 'processed';
            gr.processed = gs.nowDateTime();
            gr.update();
        }
    },
    
    type: 'MonitorMIDServer'
};
]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;tom.dilatush&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2010-10-10 19:26:16&lt;/sys_created_on&gt;
        &lt;sys_id&gt;979a5dde0ab3015252383b43d9a73436&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;18&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;MonitorMIDServer&lt;/sys_name&gt;
        &lt;sys_package display_value="Core Automation" source="com.snc.core.automation"&gt;ee2289476d6620100acb70b3534330ff&lt;/sys_package&gt;
        &lt;sys_policy/&gt;
        &lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_979a5dde0ab3015252383b43d9a73436&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;cong.thieu&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2019-10-30 17:43:01&lt;/sys_updated_on&gt;
        &lt;u_script_length&gt;4864&lt;/u_script_length&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2022-12-19 20:29:58</sys_created_on>
        <sys_id>582dcd7e2f331110d8a4d5f62799b6e6</sys_id>
        <sys_name>MonitorMIDServer</sys_name>
        <sys_package display_value="Integrations 2022" source="x_644088_integrati">4c7ca0582f0c9110d8a4d5f62799b66d</sys_package>
        <sys_policy/>
        <sys_scope display_value="Integrations 2022">4c7ca0582f0c9110d8a4d5f62799b66d</sys_scope>
        <sys_update_name>sys_metadata_link_582dcd7e2f331110d8a4d5f62799b6e6</sys_update_name>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
