<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>8a1a896a3b1000109cbbcea234efc4cf</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;package_private&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;global.IdleChatHandler&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description&gt;Timeout Idle Chats&lt;/description&gt;
        &lt;name&gt;IdleChatHandler&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var IdleChatHandler = Class.create();
IdleChatHandler.prototype = {
    initialize: function() {},

    process: function(idle_reminder_timeout, idle_cancel_timeout, start_timer_on_agent_message) {
        var conversations = {};
        // Get All conversations which are `chatInProgress` or'autoPilotInProgress' state, not messaging type and the client is online
        conversations = this.getAllConversations();
        if (start_timer_on_agent_message == "true") { //only get conversations that agent has responded to
            conversations = this.getConversationsAgentHasRespondedTo(conversations);
        }

        // Set Last Client Activity times for the conversations
        this.setLastClientActivityTimesBatched(conversations, start_timer_on_agent_message);

        // Idle Reminder Threshold based on `idle_reminder_timeout` (given in seconds)
        var idleReminderThreshold = new GlideDateTime().getNumericValue() - (idle_reminder_timeout * 1000); // In Millis
        // Idle Cancel Threshold based on `idle_cancel_timeout` (given in seconds)
        var idleCancelThreshold = new GlideDateTime().getNumericValue() - (idle_cancel_timeout * 1000); // In Millis

        var toBeCancelledConversations = [];
        var toBeRemindedConversations = [];
        var removeReminderConversations = [];

        for (var conversationId in conversations) {

            if (!this.isViableInProcessConversation(conversationId)) {
                continue;
            }

            var lastActivityTime = new GlideDateTime(conversations[conversationId]).getNumericValue(); //In Millis

            /*
               Client lastActivityTime is after the idleReminderThreshold

               CLIENT HAS BECOME ACTIVE AFTER REMINDER IS SENT
            */

            if (lastActivityTime &gt;= idleReminderThreshold) {
                removeReminderConversations.push(conversationId);
                continue;
            }

            /*
            	 Client lastActivityTime is before the idleReminderThreshold
            	 Client lastActivityTime is after the idleCancelThreshold

            	 CLIENT NEEDS TO BE SENT A REMINDER THAT HE IS INACTIVE
            */

            if (lastActivityTime &lt; idleReminderThreshold &amp;&amp; lastActivityTime &gt;= idleCancelThreshold) {
                toBeRemindedConversations.push(conversationId);
                continue;
            }

            /*
            	Client lastActivityTime is before the idleCancelThreshold

            	CLIENT HAS BEEN INACTIVE EVEN AFTER THE REMINDER IS SENT
            */

            if (lastActivityTime &lt; idleCancelThreshold) {
                toBeCancelledConversations.push(conversationId);
            }
        }

        this.removeReminderConversations(removeReminderConversations);
        this.sendReminderConversations(toBeRemindedConversations);
        this.updateCancelledConversations(toBeCancelledConversations, true);

    },

    isViableInProcessConversation: function(conversationId) {
        try {
            return sn_cs.VASystemObject.isLiveChatInProgress(conversationId);
        } catch (err) {
            // log the exception with the conversation Id
            gs.error('IdleChatHandler exception while checking viability for conversation ' + conversationId + ': ' + GlideLog.getStackTrace(err));

            //continue processing with next conversation
            return false;
        }
    },

    getAllConversations: function() {
        var conversations = {};
        var gr = new GlideRecord("sys_cs_session_binding");
        gr.addQuery("topic.state", "IN", "chatInProgress,autoPilotInProgress");
        gr.addNullQuery("topic.conversation_completed");
        gr.addQuery("online", true);
        gr.query();
        while (gr.next()) {
            var convId = gr.getValue("topic");
            if (!this.isProcessable(convId))
                continue;

            conversations[convId] = gr.topic.getRefRecord().getValue('sys_updated_on');
        }
        return conversations;
    },

    getConversationsAgentHasRespondedTo: function(conversations) {
        var newConversations = {};

        gr = new GlideAggregate("sys_cs_message");
        gr.addQuery("conversation", "IN", Object.keys(conversations).join(","));
        gr.addQuery("direction", "outbound");
        gr.addQuery("is_agent", "true");
        gr.addQuery("message_type", "IN", ["Text", "Rich"]);
        gr.addNullQuery("visibility_type");
        gr.addAggregate("MAX", "sys_updated_on");
        gr.addAggregate("COUNT");
        gr.groupBy('conversation');
        gr.query();

        while (gr.next()) {
            if (gr.getAggregate("COUNT") &gt; 1) {
                newConversations[gr.getValue("conversation")] = gr.getAggregate('MAX', 'sys_updated_on');
            }
        }
        return newConversations;
    },

    isProcessable: function(convId) {
        try {
            return (sn_cs.VASystemObject.getInteractionType(convId) == 'chat');
        } catch (err) {
            // log the exception with the conversation Id
            gs.error('IdleChatHandler exception getting interaction type for conversation ' + convId + ': ' + GlideLog.getStackTrace(err));
            //continue processing with next conversation
            return false;
        }
    },
    setLastClientActivityTimesBatched: function(conversations, start_timer_on_agent_message) {
        //updates the conversation in batches
        var batchSize = 100;
        var noOfConversations = Object.keys(conversations).length;
        for (var i = 0; i &lt; noOfConversations; i += batchSize) {
            this.setLastClientActivityTimes(conversations, start_timer_on_agent_message, i, i + batchSize);
        }
    },
    // Consider only last `inbound` message
    setLastClientActivityTimes: function(conversations, start_timer_on_agent_message, startIndex, endIndex) {
        var conversationIds = Object.keys(conversations).slice(startIndex, endIndex);
        if (conversationIds.length &gt; 0) {
            var gr = new GlideAggregate("sys_cs_message");
            gr.addQuery("conversation", "IN", conversationIds);
            var q1 = gr.addQuery("direction", "inbound");

            //checks for client activity only after the agent's first message
            if (start_timer_on_agent_message == "true") {
                q1.addOrCondition("direction", "outbound").addCondition("message_type", "IN", ["Text", "Rich"]).addCondition("is_agent", "true");
            } else {
                q1.addOrCondition("direction", "outbound").addCondition("payload", "CONTAINS", "SwitchToLiveAgent");
            }

            gr.addAggregate("MAX", "sys_updated_on");
            gr.groupBy('conversation');
            gr.query();
            while (gr.next()) {
                //make time starts based off agent response
                conversations[gr.getValue("conversation")] = gr.getAggregate('MAX', 'sys_updated_on');
            }
        }
    },

    // Client has become active, No need to send reminder, mark the client 'online'
    removeReminderConversations: function(conversations) {
        var gr = new GlideRecord("sys_cs_session_binding");
        gr.addQuery("topic", "IN", conversations);
        gr.setValue('sent_reminder', false);
        gr.setValue('online', true);
        gr.updateMultiple();
    },

    // Client has been inactive, Send a reminder
    sendReminderConversations: function(conversations) {
        var gr = new GlideRecord("sys_cs_session_binding");
        gr.addQuery("topic", "IN", conversations);
        gr.setValue('sent_reminder', true);
        gr.updateMultiple();
    },

    // Client has been inactive since long even though the reminder is send
    // Cancel the conversation and mark the client offline
    // checkReminder is a boolean indicating we will ensure the
    // sent_reminder flag is true before we cancel
    updateCancelledConversations: function(conversations, checkReminder) {
        var gr = new GlideRecord("sys_cs_session_binding");
        gr.addQuery("topic", "IN", conversations);
        if (checkReminder) {
            // method invoked from cancel timeout, check for remainder flag and send reminder if not sent
            this.sendReminderForToBeCancelledConversations(conversations);
            gr.addQuery('sent_reminder', true);
        }
        gr.setValue('online', false);
        gr.updateMultiple();
    },

    //Send Reminder for Conversations to be cancelled due to time out but never got reminder message
    sendReminderForToBeCancelledConversations: function(conversations) {
        var gr = new GlideRecord("sys_cs_session_binding");
        gr.addQuery("topic", "IN", conversations);
        gr.addQuery('sent_reminder', false);
        gr.setValue('sent_reminder', true);
        gr.updateMultiple();
    },

    //Look for session bindings that have the client_connected set to false
    //if they haven't been updated in a given amount of time, cancel the conversation
    processDisconnectedSessions: function(disconnect_timeout) {
        var disconnectedThreshold = new GlideDateTime();
        // subtract the timeout value from current date/time to get threshold
        // look for anything disconnected before that date/time
        disconnectedThreshold.addSeconds(-1 * disconnect_timeout);

        var gr = new GlideRecord("sys_cs_session_binding");
        gr.addQuery("topic.state", "IN", "chatInProgress,autoPilotInProgress");
        gr.addNullQuery("topic.conversation_completed");
        gr.addQuery("topic.device_type", "!=", "adapter");
        gr.addQuery("online", true);
        gr.addQuery("client_connected", false);
        gr.addQuery("sys_updated_on", "&lt;", disconnectedThreshold.getValue());
        gr.query();

        var toBeCancelledConversations = [];

        while (gr.next()) {
            toBeCancelledConversations.push(gr.getValue("topic"));
        }

        this.updateCancelledConversations(toBeCancelledConversations, false);
    },

    type: 'IdleChatHandler'
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2019-10-07 22:00:00&lt;/sys_created_on&gt;
        &lt;sys_id&gt;8a1a896a3b1000109cbbcea234efc4cf&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;164&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;IdleChatHandler&lt;/sys_name&gt;
        &lt;sys_package display_value="Glide Conversation Server" source="com.glide.cs"&gt;f9f62e472f000110d8a4d5f62799b60c&lt;/sys_package&gt;
        &lt;sys_policy/&gt;
        &lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_8a1a896a3b1000109cbbcea234efc4cf&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2022-05-25 08:23:42&lt;/sys_updated_on&gt;
        &lt;u_script_length&gt;10035&lt;/u_script_length&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2022-12-19 20:29:19</sys_created_on>
        <sys_id>87fc857e2f331110d8a4d5f62799b69f</sys_id>
        <sys_name>IdleChatHandler</sys_name>
        <sys_package display_value="Integrations 2022" source="x_644088_integrati">4c7ca0582f0c9110d8a4d5f62799b66d</sys_package>
        <sys_policy/>
        <sys_scope display_value="Integrations 2022">4c7ca0582f0c9110d8a4d5f62799b66d</sys_scope>
        <sys_update_name>sys_metadata_link_87fc857e2f331110d8a4d5f62799b69f</sys_update_name>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
