<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>64dc472f0a0a2c962fc761bcbe3207dd</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;public&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;global.OnCallUserReminder&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description&gt;User Reminder data for sending On-call user reminder emails. Used by "On-call Reminders NG"&lt;/description&gt;
        &lt;name&gt;OnCallUserReminder&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var OnCallUserReminder = Class.create();

OnCallUserReminder.prototype = {
   
  OCR_REMINDERS_SHOWTZ: 'com.snc.on_call_rotation.reminders.showtz',
  OCR_REMINDERS_LOG: 'com.snc.on_call_rotation.reminders.log',
   
  initialize : function() {
     this.entries = {}; // entry per {group,rota,roster}
     this.userTimeZone = '';
     this.lu = new GSLog(this.OCR_REMINDERS_LOG, this.type);
     this.showTZ = gs.getProperty(this.OCR_REMINDERS_SHOWTZ, 'false') == 'true';
  },
	
  /**
   *
   * Adds/updates the arguments passed to it to this.entries
   *
   */
  addOnCall: function(group, rota, roster, timespan, userTimeZone) {
     var key = 'group:' + group + ';rota:' + rota + ';roster:' + roster;
     var entry = {};
     var timeSpanList = [];
     if (!this.entries[key]) {
        entry['group'] = group;
        entry['rota'] = rota;
        entry['roster'] = roster;
        timeSpanList.push(timespan);
        entry['timespans'] = timeSpanList;
        this.userTimeZone = userTimeZone;
        this.entries[key] = entry;
     }
     else {
        entry = this.entries[key];
        timeSpanList = entry['timespans'];
        timeSpanList.push(timespan);
     }
  },

   /**
    * 
    * Combine timeSpanLists (for each identical entry key) into a consolidated list of ScheduleDateTimeSpan if the times can be combined.
    * This assumes that the spans in the list appear in the order by start time.  Note that differences of one second are 
    * forgiven.
    * 
    * For example, these two spans:
    *           2008-03-17 00:00:00 - 2008-03-17 23:59:59
    *           2008-03-18 00:00:00 - 2008-03-18 23:59:59
    * Will be combined into a single span:
    *           2008-03-17 00:00:00 - 2008-03-18 23:59:59
    */
   combineSpans: function() {
      for (var key in this.entries) {
         var newSpans = [];
         //gs.print("combineSpans: " + key);
         var entry = this.entries[key];
         var timeSpanList = entry['timespans'];
         if (timeSpanList.length == 0) {
            // entry['timespans'] = newSpans;
            return;
         }
         var priorSpan = timeSpanList[0];
         for (var i=1; i&lt;timeSpanList.length; i++) {
            var thisSpan = timeSpanList[i];
            var adjacentTo = priorSpan.adjacentTo(thisSpan);
            if (adjacentTo == 1) { // prior span starts immediately prior to this span?
               if (priorSpan.getEnd().compareTo(thisSpan.getEnd()) == -1) // this time has a later end time so use it
                  priorSpan.setEnd(thisSpan.getEnd());
            } else {
               newSpans.push(priorSpan);
               priorSpan = thisSpan;
            }
         }
         newSpans.push(priorSpan);
         entry['timespans'] = newSpans;
      }
   },

  // XXX: should store userTimeZone within the entry itself
  toStringTZ: function(userTimeZone) {
     var times = "";
     for (var key in this.entries) {
        var entry = this.entries[key];
        var group = entry['group'];
        var rota  = entry['rota'];
        var roster= entry['roster'];
        var timeSpanList = entry['timespans'];

        times += "\n";
        times += this.grrToText(group, rota, roster);
        times += "\n";

        for (var i=0; i&lt;timeSpanList.length; i++) {
           var span = timeSpanList[i]; // span is a com.glide.schedules.ScheduleDateTimeSpan
           var span_text = this.spanToText(span, userTimeZone);
           if (i &gt; 0)
              times += "\n";
           times += span_text;
        }
     }
     return times;
  },
	
  /**
   *
   * Takes ScheduleDateTimeSpan and time zone and returns the String representation of the ScheduleDateTimeSpan 
   *
   */
  spanToText: function(span, userTimeZone) {
     var fromTimeText = this.toTimeZoneText(span.getStart(), userTimeZone);
     var toTimeText = this.toTimeZoneText(span.getEnd(), userTimeZone);
     var toText = gs.getMessage("to");
     var span_text = fromTimeText + " " + toText + " " + toTimeText;
     if (this.showTZ || this.lu.debugOn())
        span_text += " [" + userTimeZone + "]";
     return span_text;
  },
	
  /**
   *
   * Takes ScheduleDateTime sdt and time zone and returns the String representation of the sdt
   *
   */
  toTimeZoneText: function(sdt, timeZone) {
     sdt.setTimeZone(timeZone);
     var tzID = sdt.getTimeZone();
     var gdt = sdt.getGlideDateTime();
     gdt.setDebugTZ(tzID);
     return gdt.getDisplayValue() + '';
  },
	
  /**
   *
   * Takes sys_id of sys_user_group, cmn_rota and cmn_rota_roster records and 
   * returns the String representation of the associated records separated by comma.
   *
   */
  grrToText: function( groupId, rotaId, rosterId ) {
     var toText = "";
     var gr = new GlideRecord('sys_user_group');
     if (gr.get(groupId))
       toText += gr.name;
     gr = new GlideRecord('cmn_rota');
     if (gr.get(rotaId)) {
       toText += ", " + gr.name;
     }
     if (typeof(rosterId) != 'undefined') {
       gr = new GlideRecord('cmn_rota_roster');
       if (gr.get(rosterId))
          toText += ", " + gr.name;
     }
     return toText;
  },

  type: 'OnCallUserReminder'
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;james.grinter&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2010-11-22 10:18:53&lt;/sys_created_on&gt;
        &lt;sys_id&gt;64dc472f0a0a2c962fc761bcbe3207dd&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;59&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;OnCallUserReminder&lt;/sys_name&gt;
        &lt;sys_package display_value="On-Call Scheduling" source="com.snc.on_call_rotation"&gt;37d4c9836de620100acb70b3534330d3&lt;/sys_package&gt;
        &lt;sys_policy/&gt;
        &lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_64dc472f0a0a2c962fc761bcbe3207dd&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2021-04-07 02:10:54&lt;/sys_updated_on&gt;
        &lt;u_script_length&gt;5137&lt;/u_script_length&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2022-12-19 20:28:03</sys_created_on>
        <sys_id>60bcc9fa2f331110d8a4d5f62799b631</sys_id>
        <sys_name>OnCallUserReminder</sys_name>
        <sys_package display_value="Integrations 2022" source="x_644088_integrati">4c7ca0582f0c9110d8a4d5f62799b66d</sys_package>
        <sys_policy/>
        <sys_scope display_value="Integrations 2022">4c7ca0582f0c9110d8a4d5f62799b66d</sys_scope>
        <sys_update_name>sys_metadata_link_60bcc9fa2f331110d8a4d5f62799b631</sys_update_name>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
