<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>9845c08d73d22010f14a063f34f6a7fa</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;public&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;global.AutoResolutionUtil&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description/&gt;
        &lt;name&gt;AutoResolutionUtil&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var AutoResolutionUtil = Class.create();
AutoResolutionUtil.ML_SOLUTION_DEFINITION_TABLE = "ml_capability_definition_base";

AutoResolutionUtil.getConfigurationForTask = function(taskTableName) {
	var autoResConfigGr = new GlideRecord(AutoResolutionConstants.CONFIG_TABLE_NAME);
	autoResConfigGr.addQuery(AutoResolutionConstants.CONFIGURATION_TABLENAME_FIELD_NAME, taskTableName);
	autoResConfigGr.query();
		
	if (autoResConfigGr.next())
		return autoResConfigGr.getUniqueValue();

	return null;
};

/**
 *
 * @param taskTableName
 * @param fieldNames an array of IAR config field names
 * @returns {{}} JSON with multiple key value pairs of {"fieldName" : "fieldValue"} from IAR config table
 */
AutoResolutionUtil.getConfigurationFieldValuesForTaskTable = function(taskTableName, fieldNames) {
	if (gs.nil(fieldNames) &amp;&amp; fieldNames.length &lt;= 0) 
		return {};
		
	var autoResConfigGr = new GlideRecord(AutoResolutionConstants.CONFIG_TABLE_NAME);
	autoResConfigGr.addQuery(AutoResolutionConstants.CONFIGURATION_TABLENAME_FIELD_NAME, taskTableName);
	autoResConfigGr.query();
	
	var response = {};	
	if (autoResConfigGr.next()) {
		for (var i=0; i&lt;fieldNames.length; i++) {
			var fieldName = fieldNames[i];
			response[fieldName] = autoResConfigGr.getValue(fieldName);
		}		
	}
	return response;
};

/**
* @param taskTableName
* @returns {result{'assign_to', 'task_assignment_template_name'}}
* if the assign_to field doesn't exist on the table return Virtual agent user id (for ZDT compatibility)
*/
AutoResolutionUtil.getAssignToAndPostTaskAssignmentTemplateFromTaskConfig = function(taskTableName) {	
	var result = {};
	var autoResConfigGr = new GlideRecord(AutoResolutionConstants.CONFIG_TABLE_NAME);
	if (!autoResConfigGr.isValidField(AutoResolutionConstants.CONFIGURATION_ASSIGN_TO_FIELD_NAME)) {
		result.assign_to = new AutoResolutionContextHelper()._getVAUserID();
		result.task_assignment_template_name = '';
		return result;
	}
	
	autoResConfigGr.addQuery(AutoResolutionConstants.CONFIGURATION_TABLENAME_FIELD_NAME, taskTableName);
	autoResConfigGr.query();		
	if (autoResConfigGr.next()) {
		result.assign_to = autoResConfigGr.getValue(AutoResolutionConstants.CONFIGURATION_ASSIGN_TO_FIELD_NAME);
		result.task_assignment_template_name = autoResConfigGr.task_assignment_template.name;
	}

	return result;
};

AutoResolutionUtil.getBotUserId = function(taskTableName) {
	var result = AutoResolutionUtil.getAssignToAndPostTaskAssignmentTemplateFromTaskConfig(taskTableName);		
	if (!gs.nil(result) &amp;&amp; JSON.stringify(result) !== '{}') 
		return result.assign_to;
};

AutoResolutionUtil.getSessionLanguage = function() {
	return gs.getSession().getLanguage();
};

AutoResolutionUtil.checkIARModelExists = function() {
	var result = {};
	var modelExists = false;
	
	var autoResConfigGr = new GlideRecord(AutoResolutionConstants.CONFIG_TABLE_NAME);
	autoResConfigGr.addQuery('target_table_name', AutoResolutionConstants.INCIDENT_TABLE_NAME);
	autoResConfigGr.addNotNullQuery('ml_solution_name');
	autoResConfigGr.query();
	
	if (!autoResConfigGr.next()) {
		modelExists = false;
		result.modelExists = modelExists;
	} else {
		modelExists = true;
		var solutionName = autoResConfigGr.getValue('ml_solution_name');
		var trainingState = autoResConfigGr.getValue('ml_training_state');
		var lastUpdate = autoResConfigGr.getValue('ml_status_last_updated');
		var trainingProgress = autoResConfigGr.getValue('ml_training_progress');
		var configurationActive = autoResConfigGr.getValue('active');
		var configurationSysId = autoResConfigGr.getUniqueValue();
		var latestTrainedVersion = AutoResolutionUtil.getLatestTrainedVersionNumber(configurationSysId, solutionName);

		result.modelExists = modelExists;
		result.solutionName = solutionName;
		result.trainingState = trainingState;
		result.trainingProgress = trainingProgress;
		result.configurationActive = configurationActive;
		result.lastUpdate = lastUpdate;
		result.latestTrainedVersion = latestTrainedVersion;
		result.configurationSysId = configurationSysId;
	}
	
	return result;
};

AutoResolutionUtil.getLatestTrainedVersionNumber = function(autoResConfigSysId, solutionName) {
	var mlHeper = new AutoResolutionMLHelper(autoResConfigSysId);
	return mlHeper.getActiveSolutionVersionNumberForSolutionName(solutionName);
};

// This method is called by "Check mandatory values before save BR" on sys_cs_auto_resolution_intent_topic_map table. 
// This is because, on the AR config form, in the embedded list, even empty fields will be saved without this, even though
// mandatory fields were filled in
AutoResolutionUtil.validateMandatoryFieldsOnIntentTopicMap = function(intentToTopicMapGr) {
	var emptyFields = [];
	if (gs.nil(intentToTopicMapGr.getValue('ar_intent')))
		emptyFields.push(intentToTopicMapGr.ar_intent.getLabel());
	
	if (gs.nil(intentToTopicMapGr.getValue('matched_topic')))
		emptyFields.push(intentToTopicMapGr.matched_topic.getLabel());

	if (emptyFields.length &gt; 0)
		throw gs.getMessage('The following mandatory fields are not filled in: {0}', emptyFields.join(', '));
};

/*
Check if there is atleast one active intent topic map record
 */
AutoResolutionUtil.isAnyIntentTopicMapRecordActive = function() {
	var intentTopicMapGr = new GlideRecord(AutoResolutionConstants.INTENT_TOPIC_MAP_TABLE_NAME);
	intentTopicMapGr.addActiveQuery();
	intentTopicMapGr.query();

	return intentTopicMapGr.next();
};

/*
Check if any records exist in intent topic map table
 */
AutoResolutionUtil.intentTopicMapRecordsExist = function() {
	var intentTopicMapGr = new GlideRecord(AutoResolutionConstants.INTENT_TOPIC_MAP_TABLE_NAME);
	intentTopicMapGr.query();

	return intentTopicMapGr.next();
};

AutoResolutionUtil.updateIntentTopicMapRecords = function() {
	var logger = new AutoResolutionLoggingUtils()
		.withName('AutoResolutionUtil')
		.createLogger();
	var intentTopicMapGr = new GlideRecord(AutoResolutionConstants.INTENT_TOPIC_MAP_TABLE_NAME);
	intentTopicMapGr.query();
	while (intentTopicMapGr.next()) {
		var intent = intentTopicMapGr.getValue("ar_intent");
		var topicGr = intentTopicMapGr.getElement('matched_topic').getRefRecord();
		var topicResults = AutoResolutionUtil.getActiveTopicForDomainAndIntent(
			intentTopicMapGr.getElement("ar_configuration").getRefRecord(), intent);
		if (Object.keys(topicResults).length === 0) {
			logger.info('[AutoResolutionUtil] No matching active topics found for intent {0}.', intent);
		}
		else {
			intentTopicMapGr.setValue("matched_topic", topicResults['topicSysId']);
			intentTopicMapGr.update();
			logger.info('[AutoResolutionUtil] Successfully updated matched topic for intent {0}, from {1} to {2}.', intent,
				topicGr.getValue("name"), topicResults['topicName']);
		}
	}
};

/**
 *
 * @param domainGr
 * @returns {topicList[]}
 */
AutoResolutionUtil.getActiveTopicsForDomain = function(domainGr) {
	var topicList = [];
	var topicGr = new GlideRecord('sys_cs_topic');
	topicGr.addDomainQuery(domainGr);
	topicGr.addQuery('active', true);
	topicGr.addQuery('visible', true); //exclude preview topics (name starting with *_PRVW*)
	topicGr.query();
	while (topicGr.next())
		topicList.push(topicGr.getValue('sys_id'));
	return topicList;
};

/**
 *
 * @param domainGr
 * @param intent
 * @returns {result {topicName, topicSysId}}
 * When a topic is duplicated and published from the designer, nlu_intent is not populated on the sys_cs_topic table
 * Get the topic from sys_cs_topic_language record which has the expected intent and check if topic is active and visible
 */
AutoResolutionUtil.getActiveTopicForDomainAndIntent = function(domainGr, intent) {
	var result = {};
	var topicLanguageGr = new GlideAggregate('sys_cs_topic_language');
	topicLanguageGr.addDomainQuery(domainGr);
	topicLanguageGr.addQuery("nlu_intent", intent);
	//There can be many topic language records for different languages for the same topic
	topicLanguageGr.groupBy("cs_topic_id");
	topicLanguageGr.query();
	while (topicLanguageGr.next()) {
		var topicId = topicLanguageGr.getValue("cs_topic_id");
		var topicGr = new GlideRecord('sys_cs_topic');
		topicGr.addQuery("sys_id", topicId);
		topicGr.addQuery('active', true);
		topicGr.addQuery('visible', true); //exclude preview topics (name starting with *_PRVW*)
		topicGr.query();
		//There can be only one active Topic record for a particular intent, return the result when its found
		if (topicGr.next()) {
			result.topicSysId = topicGr.getUniqueValue();
			result.topicName = topicGr.getValue("name");
			return result;
		}
	}
	return result;
};

/**
 *
 * @param predictionFields comma separated string
 * @param taskGr
 * @returns {{}} JSON with multiple key value pairs of {"fieldName" : "fieldValue"} from task table
 */
AutoResolutionUtil.buildPredictionInputs = function(predictionFields, taskGr) {
	var predictionInputs = {};
	if (gs.nil(predictionFields))
		return {};

	var fieldsArray = predictionFields.split(",");
	
	for (var i=0; i&lt;fieldsArray.length; i++) {
		
		var val = taskGr.getValue(fieldsArray[i]);
		
		if (!gs.nil(val)) 
			predictionInputs[fieldsArray[i]] = val;
	}
	return predictionInputs;
};

/**
 *
 * @param {string} className
 * @return {string}
 */
AutoResolutionUtil.getPortalSuffixForClass = function(className) {
	var autoResolutionConfigGr = new GlideRecord(AutoResolutionConstants.CONFIG_TABLE_NAME);
	autoResolutionConfigGr.addQuery('table', className);
	autoResolutionConfigGr.query();

	if (autoResolutionConfigGr.next())
		return autoResolutionConfigGr.portal.url_suffix.toString();
};

/**
 * Returns required field names of the passed task table that need to be used for the inputs to LanguageX call
 * 
 * @param taskTableName : the table name registered in the config table
 * @returns {Array} an array of field names that can be found in the passed task table
 */
AutoResolutionUtil.getTaskTableFieldNamesForARPredictionInput = function(taskTableName) {
	
	var colName = AutoResolutionConstants.IAR_PREDICTION_FIELDS_COLUMN_NAME;
	
	var configGr = new GlideRecord(AutoResolutionConstants.CONFIG_TABLE_NAME);
	configGr.addQuery(AutoResolutionConstants.CONFIGURATION_TABLENAME_FIELD_NAME, taskTableName);
	configGr.query();
	
	var foundVal;	
	if (configGr.next())
		foundVal = configGr.getValue(colName);
			
	//found value can have comma-separated values.
	return gs.nil(foundVal)?[] : foundVal.split(',');
};

AutoResolutionUtil.getCapabilityFromSolutionDefintion = function(solutionName) {
	var solutionDefGr = new GlideRecord(AutoResolutionUtil.ML_SOLUTION_DEFINITION_TABLE);
	solutionDefGr.addQuery('solution_name', solutionName);
	solutionDefGr.query();
		
	if (!solutionDefGr.hasNext())
		return '';
		
	solutionDefGr.next();
	if (!gs.nil(solutionDefGr.capability))
		return solutionDefGr.capability.label + '';
		
	return '';		
};

AutoResolutionUtil.getSolutionCapabilityToPersistInDB = function(capability) {
	if (gs.nil(capability))
		return null;
	
	var solutionCapability = '';
	
	switch (capability) {
		case AutoResolutionConstants.AGENT_ZERO_CAPABILITY:
			solutionCapability = AutoResolutionConstants.ML_CAPBILITIES.AGENT_ZERO;
			break;
			
		case AutoResolutionConstants.LANGUAGEX_CAPABILITY:
			solutionCapability = AutoResolutionConstants.ML_CAPBILITIES.LANGUAGEX;
			break;
			
		case AutoResolutionConstants.AGENT_ZERO_WORKFLOW_CAPABILITY:
			solutionCapability = AutoResolutionConstants.ML_CAPBILITIES.AGENT_ZERO_WORKFLOW;
			break;
			
		default:
			break;	
	}	
	return solutionCapability;
};

AutoResolutionUtil.checkSolutionWithCapabilityExists = function(arConfigId, capabilityTypeEncodedQuery) {
	var langConfigGr = new GlideRecord(AutoResolutionConstants.CONFIG_LANGUAGE_TABLE_NAME);
	langConfigGr.addQuery("configuration", arConfigId);
	langConfigGr.addEncodedQuery(capabilityTypeEncodedQuery);
	langConfigGr.query();
	
	return langConfigGr.next();
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2021-02-11 02:39:22&lt;/sys_created_on&gt;
        &lt;sys_id&gt;9845c08d73d22010f14a063f34f6a7fa&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;178&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;AutoResolutionUtil&lt;/sys_name&gt;
        &lt;sys_package display_value="Issue Auto-Resolution" source="com.glide.cs.auto_resolution"&gt;85493a472f800110d8a4d5f62799b6a9&lt;/sys_package&gt;
        &lt;sys_policy/&gt;
        &lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_9845c08d73d22010f14a063f34f6a7fa&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2022-04-14 10:35:51&lt;/sys_updated_on&gt;
        &lt;u_script_length&gt;11799&lt;/u_script_length&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2022-12-19 20:30:17</sys_created_on>
        <sys_id>cd3d05be2f331110d8a4d5f62799b67a</sys_id>
        <sys_name>AutoResolutionUtil</sys_name>
        <sys_package display_value="Integrations 2022" source="x_644088_integrati">4c7ca0582f0c9110d8a4d5f62799b66d</sys_package>
        <sys_policy/>
        <sys_scope display_value="Integrations 2022">4c7ca0582f0c9110d8a4d5f62799b66d</sys_scope>
        <sys_update_name>sys_metadata_link_cd3d05be2f331110d8a4d5f62799b67a</sys_update_name>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
